1:HL["/_next/static/media/a34f9d1faa5f3315-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
2:HL["/_next/static/css/2eb10676cf259d3f.css","style",{"crossOrigin":""}]
0:["PWEdH4xjP9aCV2hKPEY47",[[["",{"children":["posts",{"children":[["slug","surviving-esm-and-cjs-interop","c"],{"children":["__PAGE__?{\"slug\":[\"surviving-esm-and-cjs-interop\"]}",{}]}]}]},"$undefined","$undefined",true],"$L3",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/2eb10676cf259d3f.css","precedence":"next","crossOrigin":""}]],"$L4"]]]]
5:I[4336,["39","static/chunks/39-cefea7e4f434356b.js","185","static/chunks/app/layout-2a9799121329ca53.js"],"ThemeProvider"]
6:I[3386,["39","static/chunks/39-cefea7e4f434356b.js","185","static/chunks/app/layout-2a9799121329ca53.js"],""]
7:I[6039,["39","static/chunks/39-cefea7e4f434356b.js","931","static/chunks/app/page-401250cce1be0565.js"],""]
8:I[1974,[],""]
9:I[6496,[],""]
3:[null,["$","html",null,{"lang":"en","suppressHydrationWarning":true,"children":[["$","title",null,{"children":"hai-x"}],["$","body",null,{"children":["$","$L5",null,{"attribute":"class","children":["$","div",null,{"className":"antialiased min-h-screen bg-white text-slate-900 __className_d65c78","children":["$","div",null,{"className":"max-w-2xl mx-auto py-10 px-4","children":[["$","header",null,{"children":["$","div",null,{"className":"flex items-center justify-between","children":[["$","$L6",null,{}],["$","nav",null,{"className":"ml-auto text-sm font-medium space-x-6","children":[["$","$L7",null,{"href":"/","children":"Home"}],["$","$L7",null,{"href":"/about","children":"About"}]]}]]}]}],["$","main",null,{"children":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"childProp":{"current":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children",["slug","surviving-esm-and-cjs-interop","c"],"children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$La","$Lb",null],"segment":"__PAGE__?{\"slug\":[\"surviving-esm-and-cjs-interop\"]}"},"styles":[]}],"segment":["slug","surviving-esm-and-cjs-interop","c"]},"styles":[]}],"segment":"posts"},"styles":[]}]}],["$","footer",null,{"className":"mt-8","children":[["$","hr",null,{"className":"my-4"}],["$","small",null,{"className":"flex justify-end ","children":["$","nav",null,{"className":"underline decoration-1","children":[["$","$L7",null,{"href":"https://github.com/hai-x","className":"mr-3","children":"@github"}],["$","$L7",null,{"href":"https://twitter.com/__haijie","children":"@twitter"}]]}]}]]}]]}]}]}]}]]}],null]
4:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"Surviving ESM and CJS module Interop"}],["$","meta","2",{"name":"description","content":"深入研究 ESM 和 CJS 模块方案"}],["$","meta","3",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","4",{"name":"next-size-adjust"}]]
b:["$","article",null,{"className":"py-6 prose dark:prose-invert","children":[["$","h1",null,{"className":"mb-4 break-all","children":"Surviving ESM and CJS module Interop"}],["$","p",null,{"className":"text-slate-700","children":"深入研究 ESM 和 CJS 模块方案"}],["$","hr",null,{"className":"my-6"}],[["$","p",null,{"children":["ESM 与 CJS 作为两种如今流行的模块解决方案，如何进行互操作",["$","code",null,{"children":"interop"}],"确实一大难题。本篇文章会先着手 package.json 简单介绍 CJS / ESM 模块方案。"]}],"\n",["$","h3",null,{"children":"package.json"}],"\n",["$","p",null,{"children":[["$","strong",null,{"children":"type"}],": 定义该模块会被 Node 如何解析，若无该字段，会被认为是 CJS。"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-js","children":"// my-app.js, treated as an ES module because there is a package.json\n// file in the same folder with \"type\": \"module\".\n\nimport './startup/init.js'\n// Loaded as ES module since ./startup contains no package.json file,\n// and therefore inherits the \"type\" value from one level up.\n\nimport 'commonjs-package'\n// Loaded as CommonJS since ./node_modules/commonjs-package/package.json\n// lacks a \"type\" field or contains \"type\": \"commonjs\".\n\nimport './node_modules/commonjs-package/index.js'\n// Loaded as CommonJS since ./node_modules/commonjs-package/package.json\n// lacks a \"type\" field or contains \"type\": \"commonjs\".\n"}]}],"\n",["$","p",null,{"children":".mjs/.cjs 总是作为 ESM/CJS 模块化进行加载，而不管最近的 package.json 的设置。"}],"\n",["$","p",null,{"children":[["$","strong",null,{"children":"main"}],": 定义包的主要入口点。所有版本的 Node 皆支持。"]}],"\n",["$","p",null,{"children":[["$","strong",null,{"children":"exports"}],": 定义包多个入口点，只有 12+ 版本的 Node 才支持。它可以支持定义子路径导出和条件导出，同时封装内部未导出的模块。所有的路径定义都得是以'./'开头的相对路径。"]}],"\n",["$","p",null,{"children":[["$","strong",null,{"children":"imports"}],": 创建仅适用于包本身内的导入说明符的私有映射。字段中的条目必须始终以 # 开头，以确保它们与外部包说明符没有歧义。"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-json","children":"// package.json\n{\n  \"imports\": {\n    \"#dep\": {\n      // 有先后执行顺序 先加载node 再加载default 相关文件不存在会报错\n      \"node\": \"dep-node-native\",\n      \"default\": \"./dep-polyfill.js\"\n    }\n  },\n  \"dependencies\": {\n    \"dep-node-native\": \"^1.0.0\"\n  }\n}\n"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-js","children":"// node_modules/dep-node-native/index.js\nexports.name = 'native'\n// dep-polyfill.js\nexports.name = 'polyfill'\n\n// foo.mjs\nimport a from '#dep'\n"}]}],"\n",["$","h3",null,{"children":"ESM import CJS"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-js","children":"// node_modules/colors/index.cjs\nmodule.exports = {\n  red: 'red',\n  blue: 'blue'\n}\n// my-app.mjs\nimport colors from 'colors'\n// WON'T WORK: `import { red, blue } from \"colors\";`\n\n// CAVEAT: We can't do named import, but can expand later.\nconst { red, blue } = colors\n"}]}],"\n",["$","p",null,{"children":["由于这种简单性，库作者为了兼容库的 CJS 和 ESM 两种模式，他可能需要考虑 ESM 包装器模式（",["$","a",null,{"href":"https://nodejs.org/api/packages.html#approach-1-use-an-es-module-wrapper","children":"在 Node.js 文档中建议"}],"），该模式是以 CJS 模块规范编写代码，然后在 ESM 模块的出口文件中导入 CJS 模块，并包装成 ESM 模块导出给用户使用。"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-js","children":"// package.json\n{\n    \"name\": \"my-pkg\",\n    \"main\": \"./index.js\",\n    \"exports\": {\n      \".\": {\n        \"import\": \"./wrapper.mjs\",\n        \"require\": \"./index.js\"\n      }\n    }\n  }\n\n// node_modules/my-pkg/a.js\nexports.module_name = 'a'\n\n// node_modules/my-pkg/index.js\nconst { module_name } = require('./a')\nexports.a_module_name = module_name\n\n// node_modules/my-pkg/wrapper.mjs\nimport cjs_module from './index.js'\nexport const a_module_name = cjs_module.a_module_name\n\n// use my-pkg\nimport { a_module_name } from \"my-pkg\";\nconsole.log(a_module_name); // 'a'\n\nconst { a_module_name } = require(\"my-pkg\");\nconsole.log(a_module_name); // 'a'\n"}]}],"\n",["$","h3",null,{"children":"CJS import ESM"}],"\n",["$","p",null,{"children":["先说个坏消息，在 CJS 中导入 ESM 是痛苦的。要将 ESM 文件导入 CJS，必须遵守以下所有条件：",["$","br",null,{}],"\n","1.你必须在 Node.js 上 v12.17.0+（这适用于任何与 ESM 相关的）。",["$","br",null,{}],"\n","2.",["$","a",null,{"href":"https://nodejs.org/api/esm.html#import-expressions","children":"使用动态 import() 调用"}],"，这会导致后续逻辑代码都为异步的。"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-js","children":"// esm.mjs\nexport const name = 'polyfill'\n// cjs.js\nconsole.log(require('./esm.mjs')) // Error [ERR_REQUIRE_ESM]: require() of ES Module\nimport('./esm.mjs').then((r) => console.log(r)) // [Module: null prototype] { name: 'polyfill' }\n"}]}],"\n",["$","h3",null,{"children":"ESM & CJS 互操作"}],"\n",["$","p",null,{"children":["对于 ESM 而言，import xxx 中的 xxx 指该模块的默认导出，这是一种语法糖，实际应该是 ",["$","code",null,{"children":"import { default as xxx }"}]]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-js","children":"import esm_module from './esm_module.mjs'\n"}]}],"\n",["$","p",null,{"children":"对于 CJS 而言，import xxx 的 xxx 指该模块的所有导出 即 module.exports 或 exports 对象\n这么设计的原因是 CJS 的动态的，而 ESM 的导入是静态的。\n也就是说 ESM 通过对源码的编译即可确定依赖关系，而 CJS 需运行时才可确定依赖关系。\n所以 ESM 导入现有的 CJS 需取整个对象，即 module.exports 或 exports 对象。"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-js","children":"import cjs_module from './cjs_module.js'\n"}]}],"\n",["$","p",null,{"children":"到这里，ESM 对于 CJS 的兼容设计似乎一点问题没有，但其实 export default xxx 为后续的 ESM 与 CJS 的 interop 问题埋下了祸根。"}],"\n",["$","p",null,{"children":"在 ESM 被 javascript 的所有运行环境全量支持前，人们希望在此期间使用 ESM，此时就需要使用 Babel 进行 ESM 到 CJS 的编译。"}],"\n",["$","p",null,{"children":"然而这样转换带来了一个问题：如何准确地将 ESM 编译为 CJS 呢？举个例子。"}],"\n",["$","p",null,{"children":["一个标准的 ESM 导入导出如：",["$","code",null,{"children":"export default 'foo'"}]," 与 ",["$","code",null,{"children":"import foo from 'bar'"}],"，直观上看，转换为 CJS 应该如此：",["$","code",null,{"children":"module.exports = 'foo'"}]," 与 ",["$","code",null,{"children":"const foo = require('bar')"}],"。"]}],"\n",["$","p",null,{"children":["这里暴露了一个问题，该模块的导出只能固定是",["$","code",null,{"children":"foo"}],"，如果该模块还有 ",["$","code",null,{"children":"export a"}],"、",["$","code",null,{"children":"export b"}],",",["$","code",null,{"children":"export c"}],"呢，编译后的 CJS 导出 ",["$","code",null,{"children":"exports.a = 'a';exports.b = 'b'; // ..."}],"\n将被 ",["$","code",null,{"children":"module.exports = 'foo'"}]," 覆盖"]}],"\n",["$","p",null,{"children":"所以，babel 是这样编译的："}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-js","children":"module.exports.default = 'foo'\n// 此时 CJS 导入 将带来新问题，因为 'foo' 变成了 {default:'foo'}\nconst foo = require('bar')\n"}]}],"\n",["$","p",null,{"children":"为了解决这个问题，Babel 在转化过程中，通过将属性__esModule 设置为 true，标记这个模块是编译前是 ESM。"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-js","children":"// export\n'use strict'\nObject.defineProperty(exports, '__esModule', { value: true })\nexports.default = 0\n\n// import\n;('use strict')\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod }\n  }\nObject.defineProperty(exports, '__esModule', { value: true })\nvar bar_1 = __importDefault(require('bar'))\nconsol.log('foo', bar_1.default) // 结果为0\n"}]}],"\n",["$","blockquote",null,{"children":["\n",["$","p",null,{"children":["这样通过 babel 的编译，ESM 的导入导出，会经过一层包装转化成 CJS 的导入导出，ESM 与 CJS 的交互性也趋于正常了。这个时候 Node 搞事情了，发布了 Node 的 ESM 模块实现方案，即",["$","code",null,{"children":"default"}]," 总是等于",["$","code",null,{"children":"module.exports"}],"，所以归根到底， default 默认导出问题 在 Node 平台与 Babel 之间出现了分歧。导致有些项目使用 Babel 编译，在 Node 环境运行就出现问题。"]}],"\n"]}],"\n",["$","p",null,{"children":["举个例子，在 Node 环境中，",["$","code",null,{"children":"module.exports = 非对象"}],"，会被认为是默认导出，此时",["$","code",null,{"children":"import foo"}]," 得到 ",["$","code",null,{"children":"foo"}]]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-js","children":"// export\nmodule.exports = 'foo'\n// import 符合预期 'foo'\nimport foo from './foo'\n"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-js","children":"// 而在 Babel 编译 ESM 为 CJS 后，得到的 export 为\nmodule.exports.default = 'foo'\n// 如果此时引入Babel编译后的 CJS ，就出现问题了，此时foo为 {default:'foo'}\nimport foo from './foo'\n"}]}],"\n",["$","p",null,{"children":"对于此，只能做一系列的兼容判断，以下是 esbuild 的解决方案。"}],"\n",["$","p",null,{"children":"如果导入语句被用来加载一个 CommonJS 文件，并且"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"module.exports 是一个对象"}],"\n",["$","li",null,{"children":"module.exports.__esModule 是 truthy"}],"\n",["$","li",null,{"children":"文件名不是以.mjs 或.mts 结尾，package.json 文件不包含 \"type\": \"module\""}],"\n"]}],"\n",["$","p",null,{"children":"那么 esbuild 将把默认导出设置为 module.exports.default（像 Babel 一样）。否则，默认出口将被设置为 module.exports（像 Node）。"}],"\n",["$","p",null,{"children":"请注意，这意味着默认出口在以前没有被定义的情况下现在可能是未定义的。这与 Webpack 的行为相匹配，所以希望它能更加兼容。\n还要注意，这意味着导入行为现在取决于文件的扩展名和 package.json 的内容。这也符合 Webpack 的行为，希望能提高兼容性。"}],"\n",["$","p",null,{"children":"如果一个 require 调用被用来加载一个 ES 模块文件，返回的模块命名空间对象的__esModule 属性被设置为 true。这就像 ES 模块已经通过 Babel 兼容的转换被转换为 CommonJS 一样。"}],"\n",["$","p",null,{"children":"如果导入语句或 import() 表达式被用来加载一个 ES 模块，esModule 标记现在不应该出现在模块命名空间对象上。这释放了 esModule 的导出名称，使其可以用于 ES 模块。"}],"\n",["$","p",null,{"children":"现在允许在 ES 模块中使用 __esModule 作为一个正常的导出名。这个属性可以被其他 ES 模块访问，但不能被使用 require 加载 ES 模块的代码访问，他们将会始终看到这个属性被设置为 true。"}]]]}]
a:null
