1:HL["/_next/static/media/a34f9d1faa5f3315-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
2:HL["/_next/static/css/2eb10676cf259d3f.css","style",{"crossOrigin":""}]
0:["PWEdH4xjP9aCV2hKPEY47",[[["",{"children":["posts",{"children":[["slug","webpack-splitchunks","c"],{"children":["__PAGE__?{\"slug\":[\"webpack-splitchunks\"]}",{}]}]}]},"$undefined","$undefined",true],"$L3",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/2eb10676cf259d3f.css","precedence":"next","crossOrigin":""}]],"$L4"]]]]
5:I[4336,["39","static/chunks/39-cefea7e4f434356b.js","185","static/chunks/app/layout-2a9799121329ca53.js"],"ThemeProvider"]
6:I[3386,["39","static/chunks/39-cefea7e4f434356b.js","185","static/chunks/app/layout-2a9799121329ca53.js"],""]
7:I[6039,["39","static/chunks/39-cefea7e4f434356b.js","931","static/chunks/app/page-401250cce1be0565.js"],""]
8:I[1974,[],""]
9:I[6496,[],""]
3:[null,["$","html",null,{"lang":"en","suppressHydrationWarning":true,"children":[["$","title",null,{"children":"hai-x"}],["$","body",null,{"children":["$","$L5",null,{"attribute":"class","children":["$","div",null,{"className":"antialiased min-h-screen bg-white text-slate-900 __className_d65c78","children":["$","div",null,{"className":"max-w-2xl mx-auto py-10 px-4","children":[["$","header",null,{"children":["$","div",null,{"className":"flex items-center justify-between","children":[["$","$L6",null,{}],["$","nav",null,{"className":"ml-auto text-sm font-medium space-x-6","children":[["$","$L7",null,{"href":"/","children":"Home"}],["$","$L7",null,{"href":"/about","children":"About"}]]}]]}]}],["$","main",null,{"children":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"childProp":{"current":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children",["slug","webpack-splitchunks","c"],"children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$La","$Lb",null],"segment":"__PAGE__?{\"slug\":[\"webpack-splitchunks\"]}"},"styles":[]}],"segment":["slug","webpack-splitchunks","c"]},"styles":[]}],"segment":"posts"},"styles":[]}]}],["$","footer",null,{"className":"mt-8","children":[["$","hr",null,{"className":"my-4"}],["$","small",null,{"className":"flex justify-end ","children":["$","nav",null,{"className":"underline decoration-1","children":[["$","$L7",null,{"href":"https://github.com/hai-x","className":"mr-3","children":"@github"}],["$","$L7",null,{"href":"https://twitter.com/__haijie","children":"@twitter"}]]}]}]]}]]}]}]}]}]]}],null]
4:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"webpack@4 optimization.splitChunks"}],["$","meta","2",{"name":"description","content":"webpack@4 optimization.splitChunks"}],["$","meta","3",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","4",{"name":"next-size-adjust"}]]
c:T4f7,const chunksInfoMap = new Map()

const addModuleToChunksInfoMap = (
  cacheGroup,
  cacheGroupIndex,
  selectedChunks,
  selectedChunksKey,
  module
) => {
  // Break if minimum number of chunks is not reached
  if (selectedChunks.length < cacheGroup.minChunks) return
  // Determine name for split chunk
  const name = cacheGroup.getName(module, selectedChunks, cacheGroup.key)
  // Create key for maps
  // When it has a name we use the name as key
  // Elsewise we create the key from chunks and cache group key
  // This automatically merges equal names
  const key =
    cacheGroup.key + (name ? ` name:${name}` : ` chunks:${selectedChunksKey}`)
  // Add module to maps
  let info = chunksInfoMap.get(key)
  if (info === undefined) {
    chunksInfoMap.set(
      key,
      (info = {
        modules: new SortableSet(undefined, sortByIdentifier),
        cacheGroup,
        cacheGroupIndex,
        name,
        size: 0,
        chunks: new Set(),
        reuseableChunks: new Set(),
        chunksKeys: new Set()
      })
    )
  }
  info.modules.add(module)
  info.size += module.size()
  if (!info.chunksKeys.has(selectedChunksKey)) {
    info.chunksKeys.add(selectedChunksKey)
    for (const chunk of selectedChunks) {
      info.chunks.add(chunk)
    }
  }
}
d:T541,const compareEntries = (a, b) => {
  // 1. by priority
  const diffPriority = a.cacheGroup.priority - b.cacheGroup.priority
  if (diffPriority) return diffPriority
  // 2. by number of chunks
  const diffCount = a.chunks.size - b.chunks.size
  if (diffCount) return diffCount
  // 3. by size reduction
  const aSizeReduce = a.size * (a.chunks.size - 1)
  const bSizeReduce = b.size * (b.chunks.size - 1)
  const diffSizeReduce = aSizeReduce - bSizeReduce
  if (diffSizeReduce) return diffSizeReduce
  // 4. by cache group index
  const indexDiff = a.cacheGroupIndex - b.cacheGroupIndex
  if (indexDiff) return indexDiff
  // 5. by number of modules (to be able to compare by identifier)
  const modulesA = a.modules
  const modulesB = b.modules
  const diff = modulesA.size - modulesB.size
  if (diff) return diff
  // 6. by module identifiers
  modulesA.sort()
  modulesB.sort()
  const aI = modulesA[Symbol.iterator]()
  const bI = modulesB[Symbol.iterator]()
  // eslint-disable-next-line no-constant-condition
  while (true) {
    const aItem = aI.next()
    const bItem = bI.next()
    if (aItem.done) return 0
    const aModuleIdentifier = aItem.value.identifier()
    const bModuleIdentifier = bItem.value.identifier()
    if (aModuleIdentifier > bModuleIdentifier) return -1
    if (aModuleIdentifier < bModuleIdentifier) return 1
  }
}
b:["$","article",null,{"className":"py-6 prose dark:prose-invert","children":[["$","h1",null,{"className":"mb-4 break-all","children":"webpack@4 optimization.splitChunks"}],["$","p",null,{"className":"text-slate-700","children":"webpack@4 optimization.splitChunks"}],["$","hr",null,{"className":"my-6"}],[["$","blockquote",null,{"children":["\n",["$","p",null,{"children":"本文将展开分析 webpack@4 内的优化项 SplitChunks, 注意 SplitChunks 和 Code Splitting 有所不同, 常说的 Code Splitting 一般指代码分割, 通过 动态导入 dynamic import() 实现。"}],"\n"]}],"\n",["$","p",null,{"children":"希望读者们能在阅读后学到东西, 同时 遇到疏漏/问题, 也请进行指正。"}],"\n",["$","p",null,{"children":["相关代码: ",["$","a",null,{"href":"https://github.com/haijie-x/webpack-split-chunks-demo","children":"github/webpack-split-chunks-demo"}]]}],"\n",["$","h3",null,{"children":"名词解释"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":["Chunk: 由 modules 集合 + modules 加载后会执行的方法 组成 , 可理解为 构建输出的 js 产物。\n",["$","code",null,{"children":"Each chunk has a corresponding asset. The assets are the output files - the result of bundling."}]]}],"\n",["$","p",null,{"children":"chunk 如何产生？"}],"\n",["$","p",null,{"children":"Entry Points (webpack config entry 配置项)"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-javascript","children":"// webpack.config.js\nmodule.exports = {\n  entry: './path/to/my/entry/file.js'\n}\n"}]}],"\n",["$","p",null,{"children":"动态导入语句"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-javascript","children":"import('./path/to/my/entry/file.js')\n"}]}],"\n",["$","p",null,{"children":"chunk 如何执行？"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-javascript","children":"// 模拟下 module system 里的 jsonp 方法, jsonp 具体做 缓存模块 + 执行模块\n// require 等实现不做展开\nwindow.mock_jsonp(\n  // chunk id\n  '0',\n  // chunk 包含的模块集合\n  {\n    0: (module, exports, require) => {\n      console.log(`entry module`)\n    }\n  },\n  // 执行 mock_jsonp 方法时, 将执行该函数\n  (require) => {\n    require(0)\n  }\n)\n"}]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"SplitChunks: 中文为 拆分 chunks, 拆分前 chunk-1 到 拆分后 chunk-1-1, chunk-1-2…"}],"\n",["$","p",null,{"children":"大多数情况下 chunks 的拆分 意味着 modules 的合并, 所以对 chunks 进行拆分 与 module 的关系密不可分。"}],"\n"]}],"\n"]}],"\n",["$","h3",null,{"children":"用途"}],"\n",["$","p",null,{"children":"随着业务规模/复杂度上升, Webapp 项目的体积也越来越大, 对于用户而言, 页面首屏加载速度尤为关键, 加载依赖网络, 开发者需要构建出一个适配不同网络情况/业务特性的应用产物。"}],"\n",["$","p",null,{"children":"对于一些不支持 http2 的应用, 我们需限制首屏最大并行请求数量。但对于支持 http2 的应用, 我们需充分发挥多路复用的特性。"}],"\n",["$","p",null,{"children":"对于用户流量大 & 需求经常迭代变更的应用, 每次发版, 相关改动的 bundle 都将变成冷资源, 热起来需一段时间, 故需「擅用缓存」, 从构建层面, 开发者可以辅助用户「使用缓存」, 如 chunkHash/contentHash, hashModule, 将不经常变更三方依赖抽离成单独的 vendor chunk, 将 体积较大的三方依赖 & 几乎不变更的依赖 (react/react-dom 等)做 external。"}],"\n",["$","h3",null,{"children":"常用配置项"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"chunks : 规定了什么类型的 chunk 将被拆分, 可选 all , initial, async, 其中 initial 由 EntryPoints 产生, async 由 dyn import() 产生, all 则表示所有 chunk 都可被拆分。"}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"name: 规定拆分后的 chunk 的名称。应避免使用常量字符串 or 返回相同的字符串, 若 cacheGroup 未指定 name , 这将导致不同的 cacheGroup 使用相同 name, 最终导致所有模块合并到 同一个 chunk 中。"}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"maxAsyncRequests: 动态加载 最大的并行请求数。"}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"maxInitialRequests: 首屏加载 最大的并行请求数。"}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"minChunks: 规定了拆分前的模块至少存在几个 chunk 内。"}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"minSize: 规定了拆分后的 chunk 最小体积。"}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"maxSize: 规定了拆分后的 chunk 最大体积, 该规则可能会被打破（为何会被打破, 下文分析会讲解）。"}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"cacheGroup: 定义单个 chunk 的拆分规则, 会继承, 覆盖 splitChunks.* 的任何选项, 额外多出 test, priority 和 reuseExistingChunk 属性。"}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"test: 模块匹配规则"}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"priority: 组别优先级, 如开发者新增一个组别来匹配 node_modules 里具体的某些模块, 同时 webpack 内部有 vender 组别, 开发者可通过 priority 属性提升优先级进行拆分。"}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"reuseExistingChunk: 是否复用已有 chunk, splitChunks 默认行为是通过 addChunk() 新增 chunk, 若拆分出的 chunk 的模块集合 === 已有 chunk 的模块集合, 则不新增, 相当于 「拆了个寂寞」。"}],"\n"]}],"\n"]}],"\n",["$","h3",null,{"children":"如何配置"}],"\n",["$","p",null,{"children":"选择默认配置是为了适应 Web 性能最佳实践, 但您的项目的最佳策略可能有所不同。如果您要更改配置, 则应该衡量更改的效果, 以确保带来真正的好处。"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"默认预设"}],"\n"]}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":"webpack 4: https://v4.webpack.js.org/plugins/split-chunks-plugin/#optimizationsplitchunks"}],"\n",["$","li",null,{"children":"webpack 5: https://webpack.js.org/plugins/split-chunks-plugin/#optimizationsplitchunks"}],"\n",["$","li",null,{"children":["$","a",null,{"href":"https://github.com/vercel/next.js/blob/f85d3af12d693ebed85f511f8b9f1484a71e75f0/packages/next/src/build/webpack-config.ts#L901%5D","children":"nextjs"}]}],"\n"]}],"\n",["$","h3",null,{"children":"思考"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"拆分 chunks 由构建工具完成, 这在用户侧是如何表现的？"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-javascript","children":"// main.js\nimport(\n  /* webpackChunkName:\n\"async-a\" */ './a'\n)\n\n// a.js\nimport bigFile from '30KB'\nconsole.log(bigFile)\n\n// 30KB.js\n// ...\n// 30KB 字符串, 这里不展开\n"}]}],"\n",["$","p",null,{"children":["$","strong",null,{"children":"使用 webpack 默认配置, 会将 node_modules 的模块拆分到新 chunk 内。"}]}],"\n",["$","p",null,{"children":"构建产物如下"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"async-a.chunk.js"}],"\n",["$","li",null,{"children":"main.js"}],"\n",["$","li",null,{"children":"vendors~async-a.chunk.js"}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-javascript","children":"// main.js\n\n// ...\nPromise.all(\n  /* import() | async-a */ [\n    __webpack_require__.e(0),\n    __webpack_require__.e(1)\n  ]\n).then(__webpack_require__.bind(null, 1))\n// ...\n"}]}],"\n",["$","p",null,{"children":"webpack_require.e 内部维护了一个 chunkId -> url 的 map 来动态加载 script 脚本, 函数返回一个 Promise , 这里不做具体展开。"}],"\n",["$","p",null,{"children":"源码中对 async-a 模块的加载执行, 被编译为同时加载 2 个 chunk（async-a + vendor）后 执行 async-a 模块。"}],"\n",["$","p",null,{"children":["$","strong",null,{"children":"如何确保「拆分」不影响原有的 chunkGraph 各个 chunk 节点关系？"}]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"webpack4 之前 「父 chunk → 子 chunk 」关系"}],"\n",["$","li",null,{"children":"webpack4 及之后「父 chunkGroup(chunks 集合) → 子 chunkGroup(chunks 集合) 」关系"}],"\n"]}],"\n",["$","p",null,{"children":["$","strong",null,{"children":"为什么要对数据结构进行优化？采用 chunksGroup, 而不是 chunk?"}]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"如果 依赖关系是 chunk-a → chunk-b（chunk b 依赖 chunk a）, 从 chunk-a 拆分出 chunk-a-a。此时将面临一个问题: chunk-a-a 该作为 chunk-a 的父还是子？父子关系意味着模块加载的顺序, 比如 「chunk-a 的加载 依赖着 chunk-a-a 的加载」, 两者都将导致额外的性能开销, 即 并行加载 变成 串行加载。"}],"\n",["$","p",null,{"children":["简单代码解释: ",["$","code",null,{"children":"load(chunk-a).then(()⇒{load(chunk-a-a)})"}]]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"如果 依赖关系为 chunkGroup-a → chunkGroup-b（chunkGroup-b 依赖 chunkGroup-a）, 此时从 chunk-a 拆分出 chunk-a-a, 并不影响 chunkGroup 的依赖关系, 要做的只是往 chunk-a 所在的 chunkGroup.chunks 数组 push 进 chunk-a-a。chunkGroup.chunks 里的每个 chunk 仍并行加载。"}],"\n",["$","p",null,{"children":["简单代码解释: ",["$","code",null,{"children":"chunkGroup.chunks.forEach(load)"}]]}],"\n"]}],"\n"]}],"\n",["$","p",null,{"children":["$","strong",null,{"children":"可见, 上文思考提到的内容, async-a + vendor 同属于 一个 chunkGroup。"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-javascript","children":"// lib/RuntimeTemplate.js\nblockPromise({ block, message }) {\n    // ...\n    const chunks = block.chunkGroup.chunks.filter(\n            chunk => !chunk.hasRuntime() && chunk.id !== null\n    );\n    // ...\n    if (chunks.length === 1) {\n            const chunkId = JSON.stringify(chunks[0].id);\n            return `__webpack_require__.e(${comment}${chunkId})`;\n    } else if (chunks.length > 0) {\n            const requireChunkId = chunk =>\n                    `__webpack_require__.e(${JSON.stringify(chunk.id)})`;\n            return `Promise.all(${comment.trim()}[${chunks\n                    .map(requireChunkId)\n                    .join(\", \")}])`;\n    } else {\n            return `Promise.resolve(${comment.trim()})`;\n    }\n}\n"}]}],"\n",["$","blockquote",null,{"children":["\n",["$","p",null,{"children":"https://medium.com/webpack/webpack-4-code-splitting-chunk-graph-and-the-splitchunks-optimization-be739a861366"}],"\n"]}],"\n"]}],"\n"]}],"\n",["$","h3",null,{"children":"前置了解"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":"功能的输入和输出都为 chunks, 输入的 chunks 是基于模块依赖关系初步形成的。"}],"\n",["$","li",null,{"children":"一个模块可能命中多个 cacheGroups, 最终通过 priority , test 等属性, 决定模块处于哪个 cacheGroups 中, 即模块被拆分到 哪个 chunk 中。"}],"\n",["$","li",null,{"children":"单个 module 实例 记录了其所在的所有 chunks 集合。"}],"\n",["$","li",null,{"children":"单个 chunk 实例 记录了其包含的所有 module 集合与 其所在的所有 chunkGroups 集合。"}],"\n"]}],"\n",["$","h3",null,{"children":"简略设计"}],"\n",["$","p",null,{"children":["思考一下 如果目标是 「将命中 ",["$","code",null,{"children":"splitChunks.cacheGroups.{cacheGroup}.test"}]," 的模块 都抽离到 新 chunk 内」, 我们需要怎么做？"]}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":"首先, 找到 所有匹配中的模块, 并依次找到 模块所在的 chunks 集合, 若模块被复用, 则 chunks 长度 大于等于 1。（以下的 chunks 指 模块所在的 chunks 集合）"}],"\n",["$","li",null,{"children":"判断 chunks 的长度是否 大于等于 minChunk, 若不满足, 则过滤该模块（表示 < minChunk 的 chunk 数量 依赖此模块）。"}],"\n",["$","li",null,{"children":"判断 剩余模块的总体积 是否 大于等于 minSize, 若不满足, 则退出功能。"}],"\n",["$","li",null,{"children":"判断 是否能复用已有 chunk（判断依据为 是否存在一个 chunk 包含所有剩余模块）, 若不满足, 则后续会新增 chunk, 否则复用 chunk（即新 chunk 为自身）。"}],"\n",["$","li",null,{"children":"判断 每个 chunk 实例所在的每个 chunkGroups 中的 chunks[] 数量 是否有 < maxRequest, 若不满足, 则过滤该 chunk（表示 存在某个 import/entry 会导致 大于等于 maxRequest 的 js 请求数）。（以下的 chunkGroups 指 chunk 实例所在的 chunkGroups 集合）"}],"\n",["$","li",null,{"children":"再次判断 chunks 的长度是否 大于等于 minChunk, 若不满足, 则过滤该模块。"}],"\n",["$","li",null,{"children":"遍历剩余模块: 模块所在 chunk 实例中 记录的模块集合中, 删除模块自身, 同时向所在的 chunkGroups 中添加 新 chunk, 并向 新 chunk 添加该模块。"}],"\n",["$","li",null,{"children":"判断 chunk 的总体积 是否 < maxSize, 若不满足, 则对 新 chunk 进行拆分。"}],"\n",["$","li",null,{"children":"至此所有拆分规则皆满足, 且 新 chunk 已存在。"}],"\n"]}],"\n",["$","h3",null,{"children":"深入源码"}],"\n",["$","p",null,{"children":"让我们深入下 webpack （v4.44.2）如何实现 splitChunks 功能？"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-javascript","children":"// lib/optimize/SplitChunksPlugin.js\nmodule.exports = class SplitChunksPlugin {\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap('SplitChunksPlugin', (compilation) => {\n      let alreadyOptimized = false\n      compilation.hooks.unseal.tap('SplitChunksPlugin', () => {\n        alreadyOptimized = false\n      })\n      compilation.hooks.optimizeChunksAdvanced.tap(\n        'SplitChunksPlugin',\n        (chunks) => {\n          // ...\n        }\n      )\n    })\n  }\n}\n"}]}],"\n",["$","p",null,{"children":"向 optimizeChunksAdvanced 事件钩子注册事件, 并接收到初步形成的 chunks。设立标志位 alreadyOptimized 避免重复执行功能, 除非编译阶段接收到新模块。"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-javascript","children":"const indexMap = new Map()\nlet index = 1\nfor (const chunk of chunks) {\n  indexMap.set(chunk, index++)\n}\nconst chunkSetsInGraph = new Map()\nfor (const module of compilation.modules) {\n  const chunksKey = getKey(module.chunksIterable)\n  if (!chunkSetsInGraph.has(chunksKey)) {\n    chunkSetsInGraph.set(chunksKey, new Set(module.chunksIterable))\n  }\n}\nconst chunkSetsByCount = new Map()\nfor (const chunksSet of chunkSetsInGraph.values()) {\n  const count = chunksSet.size\n  let array = chunkSetsByCount.get(count)\n  if (array === undefined) {\n    array = []\n    chunkSetsByCount.set(count, array)\n  }\n  array.push(chunksSet)\n}\n"}]}],"\n",["$","p",null,{"children":"初始化 三个数据结构 indexMap / chunkSetsInGraph / chunkSetsByCount"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":["indexMap 维护 chunk 到 index 的映射。 ",["$","code",null,{"children":"{ chunk-a ⇒ 0, chunk-b ⇒ 1, … }"}]]}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"chunkSetsInGraph 维护 chunksKey 到 chunks 集合 的映射。chunk 集合 指 模块所在的所有 chunks 集合。如 module-a 被 chunk-a, chunk-b, chunk-c 依赖, 则 module-a 的 chunks 集合为 [chunk-a, chunk-b, chunk-c] , chunksKey 由 这些 chunk 对应的 index 拼接而成。"}],"\n",["$","p",null,{"children":"补充: ”module-a 被 chunk-a, chunk-b, chunk-c 依赖” 可能有些难懂, 以下模拟过程简单解释下。"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-javascript","children":"// 源代码\n// a.js\nimport bigFile from '30KB'\nconsole.log(bigFile)\n\n// b.js\nimport bigFile from '30KB'\nconsole.log(bigFile)\n\n// c.js\nimport bigFile from '30KB'\nconsole.log(bigFile)\n\n// main.js\nimport(\n  /* webpackChunkName:\n\"async-a\" */ './a'\n)\nimport(\n  /* webpackChunkName:\n\"async-b\" */ './b'\n)\nimport(\n  /* webpackChunkName:\n\"async-c\" */ './c'\n)\n"}]}],"\n",["$","p",null,{"children":"拆分前的构建产物如下"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"main.js"}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"async-a.chunk.js 包含的模块 「30KB 」"}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"async-b.chunk.js 包含的模块 「30KB」"}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"async-c.chunk.js 包含的模块 「30KB 」"}],"\n"]}],"\n"]}],"\n",["$","p",null,{"children":"此时 我们可以认为 模块 「30KB 」被 [ async-a.chunk.js, async-b.chunk.js, async-c.chunk.js ] 依赖。"}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"chunkSetsByCount 维护 chunks 集合个数 到 chunks 集合 的映射。主要作用 是为了后续找到「所有可拆分的 chunks 组合」"}],"\n"]}],"\n"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-javascript","children":"// Create a list of possible combinations\nconst combinationsCache = new Map() // Map<string, Set<Chunk>[]>\n\nconst getCombinations = (key) => {\n  const chunksSet = chunkSetsInGraph.get(key)\n  var array = [chunksSet]\n  if (chunksSet.size > 1) {\n    for (const [count, setArray] of chunkSetsByCount) {\n      // \"equal\" is not needed because they would have been merge in the first step\n      if (count < chunksSet.size) {\n        for (const set of setArray) {\n          if (isSubset(chunksSet, set)) {\n            array.push(set)\n          }\n        }\n      }\n    }\n  }\n  return array\n}\n// ...\n// Prepare some values\nfor (const module of compilation.modules) {\n  // ...\n  const chunksKey = getKey(module.chunksIterable)\n  let combs = combinationsCache.get(chunksKey)\n  if (combs === undefined) {\n    combs = getCombinations(chunksKey)\n    combinationsCache.set(chunksKey, combs)\n  }\n  // ...\n}\n"}]}],"\n",["$","p",null,{"children":"getCombinations 方法通过 chunkSetsByCount 找到 所有「可拆分 chunks 组合」并缓存到 combinationsCache 中。"}],"\n",["$","p",null,{"children":["比如 module-a 被 chunk-a, chunk-b, chunk-c 依赖, module-b 被 chunk-b, chunk-c 依赖。那么对于 module-a, 拆分组合为 ",["$","code",null,{"children":"{ chunk-a, chunk-b, chunk-c } , { chunk-b, chunk-c }"}]]}],"\n",["$","p",null,{"children":"思考:"}],"\n",["$","p",null,{"children":["$","strong",null,{"children":"为什么要找到所有可拆分 chunks 的组合？"}]}],"\n",["$","p",null,{"children":"设想场景:"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":"module-a 从 chunk-a, chunk-b, chunk-c 拆出。"}],"\n",["$","li",null,{"children":"chunk-c 所在 chunkGroups 的 chunks 集合为 3。"}],"\n",["$","li",null,{"children":"设置规则 maxRequest = 3。"}],"\n"]}],"\n",["$","p",null,{"children":"该组合将违反了 maxRequest 规则, 该组合将被舍弃。但可满足「 组合二 module-a 从 chunk-a, chunk-b 拆出」。"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-javascript","children":"$c"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-javascript","children":"for (const module of compilation.modules) {\n  // ...\n  // For all combination of chunk selection\n  for (const chunkCombination of combs) {\n    // Break if minimum number of chunks is not reached\n    if (chunkCombination.size < cacheGroup.minChunks) continue\n    // Select chunks by configuration\n    const { chunks: selectedChunks, key: selectedChunksKey } =\n      getSelectedChunks(chunkCombination, cacheGroup.chunksFilter)\n\n    addModuleToChunksInfoMap(\n      cacheGroup,\n      cacheGroupIndex,\n      selectedChunks,\n      selectedChunksKey,\n      module\n    )\n  }\n}\n"}]}],"\n",["$","p",null,{"children":"通过 getSelectedChunks 方法筛选有哪些 chunks 可被拆分, 这里使用到了 splitChunks.chunks 值做过滤。若 chunks 配置为 “all”, 则所有 chunks 都可被选择。若 chunks 配置为 “async”, 则只能拆分 async 类型的 chunk。"}],"\n",["$","p",null,{"children":"通过 addModuleToChunksInfoMap 方法去初始化 chunksInfoMap, addModuleToChunksInfoMap 算是整个源码中较为重要的函数, 上文提到 combinationsCache 存放的是所有「可拆分的 chunks 组合」, 这里的 chunksInfoMap 存放的就是所有「拆分组合」, 它将 modules, chunks, cacheGroup 都链接在一起。"}],"\n",["$","p",null,{"children":"可能还是有些晦涩难懂, 这里以上文提到的例子展开讲解下。"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-javascript","children":"// 源代码\n// a.js\nimport bigFile from '30KB'\nconsole.log(bigFile)\n\n// b.js\nimport bigFile from '30KB'\nconsole.log(bigFile)\n\n// c.js\nimport bigFile from '30KB'\nconsole.log(bigFile)\n\n// main.js\nimport(\n  /* webpackChunkName:\n\"async-a\" */ './a'\n)\nimport(\n  /* webpackChunkName:\n\"async-b\" */ './b'\n)\nimport(\n  /* webpackChunkName:\n\"async-c\" */ './c'\n)\n\n// webpack.config.js 采用默认的 splitChunks 配置\nmodule.exports = {\n  //...\n  optimization: {\n    splitChunks: {\n      chunks: 'async',\n      minSize: 30000,\n      maxSize: 0,\n      minChunks: 1,\n      maxAsyncRequests: 5,\n      maxInitialRequests: 3,\n      automaticNameDelimiter: '~',\n      automaticNameMaxLength: 30,\n      name: true,\n      cacheGroups: {\n        vendors: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          priority: -10\n        },\n        default: {\n          minChunks: 2,\n          priority: -20,\n          reuseExistingChunk: true\n        }\n      }\n    }\n  }\n}\n"}]}],"\n",["$","p",null,{"children":"以上存在两个 cacheGroups, 显然「30KB」模块皆命中, 所有拆分组合都被列举出来了, 最终形成的 chunksInfoMap 结果如下:"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-javascript","children":"{\n\t'default name:async-a~async-b~async-c': {\n\t\tchunks:[async-a,async-b,async-c],\n\t\tcacheGroup: default,\n\t\tmodules:[30KB],\n\t\tsize:30833\n\t\t// ...\n\t}\n\t'vendors name:vendors~async-a~async-b~async-c':{\n\t\tchunks:[async-a,async-b,async-c],\n\t\tcacheGroup: vendor,\n\t\tmodules:[30KB],\n\t\tsize:30833\n\t\t// ...\n\t},\n\t'vendors name:vendors~async-a':{\n\t\tchunks:[async-a],\n\t\tcacheGroup: vendor,\n\t\tmodules:[30KB],\n\t\tsize:30833\n\t\t// ...\n\t},\n\t'vendors name:vendors~async-b':{\n\t\tchunks:[async-b],\n\t\tcacheGroup: vendor,\n\t\tmodules:[30KB],\n\t\tsize:30833\n\t\t// ...\n\t},\n\t'vendors name:vendors~async-c':{\n\t\tchunks:[async-c],\n\t\tcacheGroup: vendor,\n\t\tmodules:[30KB],\n\t\tsize:30833\n\t\t// ...\n\t}\n}\n"}]}],"\n",["$","p",null,{"children":"最重要的 chunksInfoMap 数据结构介绍完毕, 后续便是 遍历 chunksInfoMap 每次选择最优的一项 进行拆分。那么如何判断「最优」？"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-javascript","children":"$d"}]}],"\n",["$","p",null,{"children":"依次比较"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":"priority"}],"\n",["$","li",null,{"children":"chunks 数量"}],"\n",["$","li",null,{"children":"总体积减少大小（比如 组合 A 和 组合 B 拆分出的 chunk 体积都为 30833, 组合 A 从 2 个 chunk 拆出, 组合 B 从 3 个 chunk 拆出, 所以组合 B 「总体积减少 」大于 组合 A「总体积减少 」, 则最优解是 组合 B）"}],"\n",["$","li",null,{"children":"cacheGroups 索引位置"}],"\n",["$","li",null,{"children":"包含的 module 集合长度"}],"\n",["$","li",null,{"children":"两个组合内 每一个 module id 字符串"}],"\n"]}],"\n",["$","p",null,{"children":"每次遍历 都找到了最优的拆分组合, 后续就要进行 拆分判断 & 具体拆分动作了。这一部分已在上节「简略设计」中讲述, 后续源码就不再展开讲解了。"}],"\n",["$","h3",null,{"children":"总结"}],"\n",["$","p",null,{"children":"Webpack v4.44.2 版本的 SplitChunks 插件源码共 1k 行, 加上近 300 行的 deterministicGroupingForModules maxSize 拆分算法, 为 webapp 应用的性能优化提供了较为优秀的解决方案。再次感叹 webpack 的强大。"}],"\n",["$","h3",null,{"children":"相关文章"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"https://medium.com/webpack/webpack-4-code-splitting-chunk-graph-and-the-splitchunks-optimization-be739a861366"}],"\n"]}],"\n",["$","li",null,{"children":["\n",["$","p",null,{"children":"https://web.dev/articles/granular-chunking-nextjs"}],"\n"]}],"\n"]}]]]}]
a:null
