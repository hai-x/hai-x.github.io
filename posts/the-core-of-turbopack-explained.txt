1:HL["/_next/static/media/a34f9d1faa5f3315-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
2:HL["/_next/static/css/2eb10676cf259d3f.css","style",{"crossOrigin":""}]
0:["PWEdH4xjP9aCV2hKPEY47",[[["",{"children":["posts",{"children":[["slug","the-core-of-turbopack-explained","c"],{"children":["__PAGE__?{\"slug\":[\"the-core-of-turbopack-explained\"]}",{}]}]}]},"$undefined","$undefined",true],"$L3",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/2eb10676cf259d3f.css","precedence":"next","crossOrigin":""}]],"$L4"]]]]
5:I[4336,["39","static/chunks/39-cefea7e4f434356b.js","185","static/chunks/app/layout-2a9799121329ca53.js"],"ThemeProvider"]
6:I[3386,["39","static/chunks/39-cefea7e4f434356b.js","185","static/chunks/app/layout-2a9799121329ca53.js"],""]
7:I[6039,["39","static/chunks/39-cefea7e4f434356b.js","931","static/chunks/app/page-401250cce1be0565.js"],""]
8:I[1974,[],""]
9:I[6496,[],""]
3:[null,["$","html",null,{"lang":"en","suppressHydrationWarning":true,"children":[["$","title",null,{"children":"hai-x"}],["$","body",null,{"children":["$","$L5",null,{"attribute":"class","children":["$","div",null,{"className":"antialiased min-h-screen bg-white text-slate-900 __className_d65c78","children":["$","div",null,{"className":"max-w-2xl mx-auto py-10 px-4","children":[["$","header",null,{"children":["$","div",null,{"className":"flex items-center justify-between","children":[["$","$L6",null,{}],["$","nav",null,{"className":"ml-auto text-sm font-medium space-x-6","children":[["$","$L7",null,{"href":"/","children":"Home"}],["$","$L7",null,{"href":"/about","children":"About"}]]}]]}]}],["$","main",null,{"children":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"childProp":{"current":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L8",null,{"parallelRouterKey":"children","segmentPath":["children","posts","children",["slug","the-core-of-turbopack-explained","c"],"children"],"loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","template":["$","$L9",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$La","$Lb",null],"segment":"__PAGE__?{\"slug\":[\"the-core-of-turbopack-explained\"]}"},"styles":[]}],"segment":["slug","the-core-of-turbopack-explained","c"]},"styles":[]}],"segment":"posts"},"styles":[]}]}],["$","footer",null,{"className":"mt-8","children":[["$","hr",null,{"className":"my-4"}],["$","small",null,{"className":"flex justify-end ","children":["$","nav",null,{"className":"underline decoration-1","children":[["$","$L7",null,{"href":"https://github.com/hai-x","className":"mr-3","children":"@github"}],["$","$L7",null,{"href":"https://twitter.com/__haijie","children":"@twitter"}]]}]}]]}]]}]}]}]}]]}],null]
4:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"The core of Turbopack explained"}],["$","meta","2",{"name":"description","content":"The core of Turbopack explained"}],["$","meta","3",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","4",{"name":"next-size-adjust"}]]
c:T530,const main = task('main', () => {
  const baseDir = path.join(process.cwd(), 'demo')
  const outDir = path.join(process.cwd(), 'demo', 'dist')
  const entry = path.join(baseDir, '/index.js')
  const header = path.join(process.cwd(), 'demo', 'header.js')
  copyGraph(baseDir, outDir, entry, header)
  log.enable && printCentered(`🔥🔥 首次构建完成 🔥🔥`)
})

// 构建主流程
const copyGraph = task('copyGraph', (baseDir, outDir, entry, header) => {
  const relPath = path.relative(baseDir, entry)
  const output = path.join(outDir, relPath)
  copy(output, header, entry)
  const importers = getImporter(entry)
  if (importers?.length > 0)
    for (const importer of importers) {
      copyGraph(baseDir, outDir, importer, header)
    }
})

// 解析依赖文件的路径
const getImporter = task('getImporter', (entry) => {
  const ast = parse(read(entry), {
    sourceType: 'module',
    ecmaVersion: 'latest'
  })
  return (
    ast.body
      .filter((node) => node.type === 'ImportDeclaration')
      .map((node) => node.source.value)
      .filter((value) => {
        return value.startsWith('./')
      })
      .map((value) => path.join(path.dirname(entry), value)) ?? []
  )
})

// 输出构建产物
const copy = task('copy', (output, header, entry) => {
  write(output, read(header) + read(entry))
})
b:["$","article",null,{"className":"py-6 prose dark:prose-invert","children":[["$","h1",null,{"className":"mb-4 break-all","children":"The core of Turbopack explained"}],["$","p",null,{"className":"text-slate-700","children":"The core of Turbopack explained"}],["$","hr",null,{"className":"my-6"}],[["$","h2",null,{"children":"简述"}],"\n",["$","blockquote",null,{"children":["\n",["$","p",null,{"children":["来源： webpack 作者 Tobias Koppers 在 JS Nation\nJSNation 2023 上的 coding live 作品\n",["$","a",null,{"href":"https://portal.gitnation.org/contents/the-core-of-turbopack-explained-live-coding","children":"The Core of Turbopack Explained (Live Coding)"}]]}],"\n"]}],"\n",["$","blockquote",null,{"children":["\n",["$","p",null,{"children":"目的：解决 webpack 因大量查找缓存、验证失效缓存导致的开销过大问题"}],"\n"]}],"\n",["$","p",null,{"children":"本文章通过模拟一个最简构建过程来初探 Turbo Engine 的一些原理。"}],"\n",["$","h2",null,{"children":"如何工作"}],"\n",["$","p",null,{"children":["Turbo Engine 会将某些功能标记为",["$","em",null,{"children":"To be remember"}],"。当这些函数被调用时，它会记住它们被调用的内容以及它们返回的内容。然后它将其保存在缓存中。"]}],"\n",["$","p",null,{"children":"一个简单的 bundle 过程可以描述为读取源码，对源码进行构建，拼接构建产物形成最终产物 如下所示"}],"\n",["$","img",null,{"src":"/assets/the-core-of-turbopack-explained/image.png","alt":"图出自 Turbopack 官网"}],"\n",["$","p",null,{"children":["修改 ",["$","code",null,{"children":"sdk.ts"}]," 的代码时，我们需要再次构建，再次拼接产物。此时，对于 ",["$","code",null,{"children":"api.ts"}]," 文件并未改动，我们将从缓存中读取 ",["$","code",null,{"children":"api.ts"}]," 的内容再拼接即可。从而减少了对于 ",["$","code",null,{"children":"api.ts"}]," 的读取与构建产生的开销。"]}],"\n",["$","img",null,{"src":"/assets/the-core-of-turbopack-explained/image-1.png","alt":"图出自 Turbopack 官网"}],"\n",["$","p",null,{"children":"对于一个具有成千上百个文件的巨应用，构建工具需要对每个文件进行路径解析、文件读取、源码构建。所有巧用缓存（记住每次函数的调用结果）将可节省大量开销。"}],"\n",["$","p",null,{"children":["这种解决方法能让 ",["$","code",null,{"children":"Turbopack"}]," 以极快的速度进行应用程序的增量构建，当文件改动，",["$","code",null,{"children":"devServer"}]," 将快速接管并进行构建响应。"]}],"\n",["$","h3",null,{"children":"关于缓存"}],"\n",["$","p",null,{"children":["Turbo Engine 将这些内存缓存在运行内存中，而不是在硬盘内存中，这意味着，当启动 ",["$","code",null,{"children":"devServer"}]," 时，构建缓存将一直存在。直到关闭/停止 ",["$","code",null,{"children":"devServer"}]," 时，这些内存将被回收。"]}],"\n",["$","h3",null,{"children":"原理解释"}],"\n",["$","p",null,{"children":"最简构建过程"}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":"读取入口文件源码、读取被拼接的模块 Header (/*_ @copyright the-core-of-turbopack-explained _/)"}],"\n",["$","li",null,{"children":"拼接构建模块"}],"\n",["$","li",null,{"children":"输出构建产物"}],"\n",["$","li",null,{"children":"解析入口文件的依赖"}],"\n"]}],"\n",["$","p",null,{"children":["第 1,2,3 步我们统称为 ",["$","code",null,{"children":"copy"}]," 构建阶段，而后执行第 4 步 ",["$","code",null,{"children":"getImporter"}]," 构建阶段，如发现存在依赖文件，则递归执行此构建过程"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-js","children":"$c"}]}],"\n",["$","p",null,{"children":"每个构建阶段都使用了 task 函数进行包裹，该函数的主要目的是对「相同入参与函数名」函数的执行结果进行缓存。"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-js","children":"const taskCache = new TupleMap()\nexport let currentTask = null\n\nexport const task = (name, f) => {\n  return (...args) => {\n    let task = taskCache.get([name, ...args]) ?? null\n    if (!task) {\n      task = {\n        name,\n        args,\n        f,\n        result: undefined,\n        dependentTasks: new Set()\n      }\n      task.result = wrapCurrentTask(task, () => logged(name, f, args))\n      taskCache.set([name, ...args], task)\n    }\n    currentTask && task.dependentTasks.add(currentTask)\n    return task.result\n  }\n}\n"}]}],"\n",["$","h4",null,{"children":"关键函数与变量"}],"\n",["$","p",null,{"children":[["$","code",null,{"children":"logged"}]," 函数仅做日志打点用，在此不做过多解释"]}],"\n",["$","p",null,{"children":[["$","code",null,{"children":"currentTask"}]," 变量用来记录当前所处哪个构建阶段，以方便记录各个构建阶段之间的依赖关系。"]}],"\n",["$","p",null,{"children":[["$","code",null,{"children":"currentTask"}]," 变量记录还依赖 ",["$","code",null,{"children":"withCurrentTask"}]," 方法，具体操作为： 当前构建阶段的函数执行完毕后，会还原 ",["$","code",null,{"children":"currentTask"}]," 为其父级构建阶段，然后通过 ",["$","code",null,{"children":"task.dependentTasks.add(currentTask)"}]," 来记录当前构建阶段的父级构建阶段。"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-js","children":"// wrap current task to be able to track dependent tasks\nconst wrapCurrentTask = (task, f) => {\n  const oldTask = currentTask\n  currentTask = task\n  try {\n    return f()\n  } finally {\n    currentTask = oldTask\n  }\n}\n"}]}],"\n",["$","p",null,{"children":"依据此，即可构建出一个完整的 taskCache，如下图所示"}],"\n",["$","img",null,{"src":"/assets/the-core-of-turbopack-explained/image-2.png","alt":"Task Cache"}],"\n",["$","h4",null,{"children":"缓存节点属性解释"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"name: 构建阶段名，Map 的 key 之一"}],"\n",["$","li",null,{"children":"f: 构建执行函数"}],"\n",["$","li",null,{"children":"args: 执行函数的入参，Map 的 key 之一"}],"\n",["$","li",null,{"children":"dependentTasks: 代表该构建阶段函数的父级集合"}],"\n"]}],"\n",["$","p",null,{"children":["现在我们已实现第一个功能，即官网中提及的 ",["$","a",null,{"href":"https://turbo.build/pack/docs/core-concepts#function-level-caching","children":"Function-level caching"}]]}],"\n",["$","ol",null,{"children":["\n",["$","li",null,{"children":"对于重复路径的文件读取，我们可以直接从缓存中读取，而不用再次读取硬盘文件。"}],"\n",["$","li",null,{"children":"对于重复路径的依赖文件解析，我们可以直接从缓存中读取，而不用再次使用 parser 进行依赖解析。"}],"\n",["$","li",null,{"children":"..."}],"\n"]}],"\n",["$","p",null,{"children":"但是，我们还需要解决一个问题，那就是如何判断文件是否改动，以及文件改动后，让缓存失效。"}],"\n",["$","h4",null,{"children":"思考"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"如何判断文件改动：我们简单通过 fs 模块的 watch 函数进行文件监听。"}],"\n",["$","li",null,{"children":"如何使缓存失效：当文件改动后，再次进行文件读取 read 工作，并且执行冒泡操作，即递归执行父级构建阶段的函数，getImporter, write...，同时进行缓存的更新。"}],"\n"]}],"\n",["$","h4",null,{"children":"如何实现"}],"\n",["$","p",null,{"children":["先创建一个缓存失效函数，目的是重新执行 read 函数阶段，使缓存失效，更新 ",["$","code",null,{"children":"task.result"}],"，如果 task.result 发生变化，则递归执行父级构建阶段的函数。"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-js","children":"export const invalidate = (task) => {\n  const oldTaskResult = task.result\n  // recalculate task\n  logged(\n    task.name,\n    () => {\n      task.result = wrapCurrentTask(task, () => {\n        return task.f(...task.args)\n      })\n    },\n    task.args\n  )\n  // invalidate dependent tasks\n  if (JSON.stringify(oldTaskResult) !== JSON.stringify(task.result)) {\n    if (task.dependentTasks.size > 0) {\n      for (const dependentTask of task.dependentTasks) {\n        invalidate(dependentTask)\n      }\n    }\n  } else {\n    log.enable && printCentered(`🔥🔥 ${task.name} no change 🔥🔥`)\n  }\n}\n"}]}],"\n",["$","p",null,{"children":["将 ",["$","code",null,{"children":"currentTask"}]," 作为入参传入 ",["$","code",null,{"children":"invalidate"}]," 缓存失效函数中，即可明确 该入口文件 & 该构建阶段 的父级构建链，从而实现冒泡/增量构建中的一环。"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-js","children":"export const getInvalidator = () => {\n  if (!currentTask) log.enable && console.log('>>>>>no task')\n  // need to cache by another variable because currentTask is changing\n  const task = currentTask\n  return () => invalidate(task)\n}\n"}]}],"\n",["$","p",null,{"children":"下一步，让缓存失效函数与文件监听函数进行关联，当文件改动时，执行缓存失效函数。"}],"\n",["$","p",null,{"children":["借助『以 filepath 作为 key 的缓存 ",["$","code",null,{"children":"invalidatorCache"}]," 』来记录每个文件的 ",["$","code",null,{"children":"read"}]," 构建阶段的缓存失效函数。文件改动后，通过 ",["$","code",null,{"children":"invalidatorCache"}]," 找到对应的缓存失效函数，执行缓存失效函数来实现目标。"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-js","children":"export const read = task('read', (entry) => {\n  const invalidator = getInvalidator()\n  // 注册当前文件的缓存失效函数\n  invalidatorCache.set(entry, invalidator)\n  return readFileSync(entry, 'utf8', (err) => {\n    console.error('>>>>>>>read error', err)\n  })\n})\n"}]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-js","children":"watch(process.cwd(), { recursive: true }, (eventType, filename) => {\n  if (!filename) return\n  filename = resolve(filename)\n  // 找到对应的缓存失效函数\n  const invalidator = invalidatorCache.get(filename)\n  invalidator &&\n    setTimeout(() => {\n      invalidatorCache.delete(filename)\n      log.enable && console.time('file change')\n      // 执行缓存失效函数\n      invalidator()\n      log.enable && console.timeEnd('file change')\n    }, 100)\n})\n"}]}],"\n",["$","p",null,{"children":"通过以上几个函数，我们即可做到 文件改动 => 使缓存失效 => 增量构建。"}],"\n",["$","p",null,{"children":"下面我们以一个 demo 来解释一下全链路"}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-js","children":"// test/index.js\nimport { foo as foo1 } from './1.js'\nimport { foo as foo2 } from './2.js'\nimport { foo as foo3 } from './3.js'\nimport { foo as foo4 } from './4.js'\nimport { foo as foo5 } from './5.js'\nimport { foo as foo6 } from './6.js'\nimport { foo as foo7 } from './7.js'\nimport { foo as foo8 } from './8.js'\nimport { foo as foo9 } from './9.js'\nimport { foo as foo10 } from './10.js'\nimport { foo as foo11 } from './11.js'\nimport { foo as foo12 } from './12.js'\n"}]}],"\n",["$","blockquote",null,{"children":["\n",["$","p",null,{"children":"第一次执行构建过程，流程如下"}],"\n"]}],"\n",["$","img",null,{"src":"/assets/the-core-of-turbopack-explained/image-3.png","alt":"构建过程"}],"\n",["$","h4",null,{"children":["当 ",["$","code",null,{"children":"./1.js"}]," 文件改动时，执行如下"]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["重读取 ",["$","code",null,{"children":"./1.js"}]," 文件，发现 ",["$","code",null,{"children":"task.result"}]," 与之前结果不一致，更新缓存，进行冒泡，执行父级构建链"]}],"\n",["$","li",null,{"children":["执行 ",["$","code",null,{"children":"copy"}]," 构建阶段，",["$","code",null,{"children":"writeFile"}]," 输出构建结果，",["$","code",null,{"children":"task.result"}]," 为 undefined，与之前结果一致，结束执行"]}],"\n",["$","li",null,{"children":["执行 ",["$","code",null,{"children":"getImporter"}]," 构建阶段，",["$","code",null,{"children":"task.result"}]," 为 [] 空数组，JSON.stringify 后，与之前结果一致，结束执行"]}],"\n"]}],"\n",["$","h4",null,{"children":["当 ",["$","code",null,{"children":"index.js"}]," 文件改动，如新增依赖 ",["$","code",null,{"children":"import"}]," 语句"]}],"\n",["$","pre",null,{"children":["$","code",null,{"className":"language-js","children":"import { foo as foo14 } from \"./14.js\"`\n"}]}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":["重读取 ",["$","code",null,{"children":"./index.js"}]," 文件，发现 ",["$","code",null,{"children":"task.result"}]," 与之前结果不一致，更新缓存，进行冒泡，执行父级构建链"]}],"\n",["$","li",null,{"children":["执行 ",["$","code",null,{"children":"copy"}]," 构建阶段，",["$","code",null,{"children":"writeFile"}]," 输出构建结果，",["$","code",null,{"children":"task.result"}]," 为 undefined，与之前结果一致，结束执行。"]}],"\n",["$","li",null,{"children":["执行 ",["$","code",null,{"children":"getImporter"}]," 构建阶段，",["$","code",null,{"children":"task.result"}]," 数组新增一项，与之前结果不一致，进行冒泡。"]}],"\n",["$","li",null,{"children":["执行 ",["$","code",null,{"children":"./index.js"}]," 的 ",["$","code",null,{"children":"copyGraph"}]," 构建阶段，",["$","code",null,{"children":"./1.js"}]," 至 ",["$","code",null,{"children":"./13.js"}]," 的构建阶段皆被缓存，不再执行。"]}],"\n",["$","li",null,{"children":["执行 ",["$","code",null,{"children":"./14.js"}]," 的 ",["$","code",null,{"children":"copyGraph"}]," 构建阶段，未命中缓存，执行 ",["$","code",null,{"children":"copy"}]," 与 ",["$","code",null,{"children":"getImporter"}]," 构建阶段，并进行 task 缓存。"]}],"\n",["$","li",null,{"children":[["$","code",null,{"children":"./index.js"}]," 的 ",["$","code",null,{"children":"copyGraph"}]," 构建阶段的",["$","code",null,{"children":"task.result"}]," 为 undefined，与之前结果一致，结束执行。"]}],"\n"]}],"\n",["$","h2",null,{"children":"结语"}],"\n",["$","p",null,{"children":["欢迎 🔗 Fork 或 ❤️ Star 本仓库 ",["$","a",null,{"href":"https://github.com/haijie-x/the-core-of-turbopack-explained","children":"the-core-of-turbopack-explained"}]," 共同探讨与学习。"]}],"\n",["$","h2",null,{"children":"参考"}],"\n",["$","ul",null,{"children":["\n",["$","li",null,{"children":"https://portal.gitnation.org/contents/the-core-of-turbopack-explained-live-coding"}],"\n",["$","li",null,{"children":"https://turbo.build/pack/docs/core-concepts"}],"\n"]}]]]}]
a:null
